[{"title":"魔性机器人","date":"2018-07-05T05:48:56.000Z","path":"/posts/undefined/","text":"行走的机器人 body, html { position: absolute; margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; } canvas { position: absolute; width: 100%; height: 100%; background:#000; cursor: pointer; } { class Robot { constructor(color, light, size, x, y, struct) { this.x = x; this.points = []; this.links = []; this.frame = 0; this.dir = 1; this.size = size; this.color = Math.round(color); this.light = light; // ---- 创建点 ---- for (const p of struct.points) { this.points.push(new Robot.Point(size * p.x + x, size * p.y + y, p.f)); } // ---- 创建链接 ---- for (const link of struct.links) { const p0 = this.points[link.p0]; const p1 = this.points[link.p1]; const dx = p0.x - p1.x; const dy = p0.y - p1.y; this.links.push( new Robot.Link( this, p0, p1, Math.sqrt(dx * dx + dy * dy), link.size * size / 3, link.lum, link.force, link.disk ) ); } } update() { if (++this.frame % 20 === 0) this.dir = -this.dir; if ( dancerDrag && this === dancerDrag && this.size < 16 && this.frame > 600 ) { dancerDrag = null; dancers.push( new Robot( this.color, this.light * 1.25, this.size * 2, pointer.x, pointer.y - 100 * this.size * 2, struct ) ); dancers.sort(function(d0, d1) { return d0.size - d1.size; }); } // ---- 初始化 ---- for (const link of this.links) { const p0 = link.p0; const p1 = link.p1; const dx = p0.x - p1.x; const dy = p0.y - p1.y; const dist = Math.sqrt(dx * dx + dy * dy); if (dist) { const tw = p0.w + p1.w; const r1 = p1.w / tw; const r0 = p0.w / tw; const dz = (link.distance - dist) * link.force; const sx = dx / dist * dz; const sy = dy / dist * dz; p1.x -= sx * r0; p1.y -= sy * r0; p0.x += sx * r1; p0.y += sy * r1; } } // ---- 初始化点 ---- for (const point of this.points) { // ---- 拖拽事件 ---- if (this === dancerDrag && point === pointDrag) { point.x += (pointer.x - point.x) * 0.1; point.y += (pointer.y - point.y) * 0.1; } // ---- 跳舞事件 ---- if (this !== dancerDrag) { point.fn && point.fn(16 * Math.sqrt(this.size), this.dir); } // ---- 集合---- point.vx = point.x - point.px; point.vy = point.y - point.py; point.px = point.x; point.py = point.y; point.vx *= 0.995; point.vy *= 0.995; point.x += point.vx; point.y += point.vy + 0.01; } // ---- 地面 ---- for (const link of this.links) { const p1 = link.p1; if (p1.y > canvas.height * ground - link.size * 0.5) { p1.y = canvas.height * ground - link.size * 0.5; p1.x -= p1.vx; p1.vx = 0; p1.vy = 0; } } // ---- 自动居中 ---- this.points[3].x += (this.x - this.points[3].x) * 0.001; } draw() { for (const link of this.links) { if (link.size) { const dx = link.p1.x - link.p0.x; const dy = link.p1.y - link.p0.y; const a = Math.atan2(dy, dx); const d = Math.sqrt(dx * dx + dy * dy); // ---- 阴影 ---- ctx.save(); ctx.translate(link.p0.x + link.size * 0.25, link.p0.y + link.size * 0.25); ctx.rotate(a); ctx.drawImage( link.shadow, -link.size * 0.5, -link.size * 0.5, d + link.size, link.size ); ctx.restore(); // ---- 滑动 ---- ctx.save(); ctx.translate(link.p0.x, link.p0.y); ctx.rotate(a); ctx.drawImage( link.image, -link.size * 0.5, -link.size * 0.5, d + link.size, link.size ); ctx.restore(); } } } } Robot.Link = class Link { constructor(parent, p0, p1, dist, size, light, force, disk) { // ---- 缓存 ---- function stroke(color, axis) { const image = document.createElement(\"canvas\"); image.width = dist + size; image.height = size; const ict = image.getContext(\"2d\"); ict.beginPath(); ict.lineCap = \"round\"; ict.lineWidth = size; ict.strokeStyle = color; if (disk) { ict.arc(size * 0.5 + dist, size * 0.5, size * 0.5, 0, 2 * Math.PI); ict.fillStyle = color; ict.fill(); } else { ict.moveTo(size * 0.5, size * 0.5); ict.lineTo(size * 0.5 + dist, size * 0.5); ict.stroke(); } if (axis) { const s = size / 10; ict.fillStyle = \"#000\"; ict.fillRect(size * 0.5 - s, size * 0.5 - s, s * 2, s * 2); ict.fillRect(size * 0.5 - s + dist, size * 0.5 - s, s * 2, s * 2); } return image; } this.p0 = p0; this.p1 = p1; this.distance = dist; this.size = size; this.light = light || 1.0; this.force = force || 0.5; this.image = stroke( \"hsl(\" + parent.color + \" ,30%, \" + parent.light * this.light + \"%)\", true ); this.shadow = stroke(\"rgba(0,0,0,0.5)\"); } }; Robot.Point = class Point { constructor(x, y, fn, w) { this.x = x; this.y = y; this.w = w || 0.5; this.fn = fn || null; this.px = x; this.py = y; this.vx = 0.0; this.vy = 0.0; } }; // ---- 设置 canvas ---- const canvas = { init() { this.elem = document.querySelector(\"canvas\"); this.resize(); window.addEventListener(\"resize\", () => this.resize(), false); return this.elem.getContext(\"2d\"); }, resize() { this.width = this.elem.width = this.elem.offsetWidth; this.height = this.elem.height = this.elem.offsetHeight; ground = this.height > 500 ? 0.85 : 1.0; for (let i = 0; i < dancers.length; i++) { dancers[i].x = (i + 2) * canvas.width / 9; } } }; // ---- 设置点 ---- const pointer = { init(canvas) { this.x = 0; this.y = 0; window.addEventListener(\"mousemove\", e => this.move(e), false); canvas.elem.addEventListener(\"touchmove\", e => this.move(e), false); window.addEventListener(\"mousedown\", e => this.down(e), false); window.addEventListener(\"touchstart\", e => this.down(e), false); window.addEventListener(\"mouseup\", e => this.up(e), false); window.addEventListener(\"touchend\", e => this.up(e), false); }, down(e) { this.move(e); for (const dancer of dancers) { for (const point of dancer.points) { const dx = pointer.x - point.x; const dy = pointer.y - point.y; const d = Math.sqrt(dx * dx + dy * dy); if (d < 60) { dancerDrag = dancer; pointDrag = point; dancer.frame = 0; } } } }, up(e) { dancerDrag = null; }, move(e) { let touchMode = e.targetTouches, pointer; if (touchMode) { e.preventDefault(); pointer = touchMode[0]; } else pointer = e; this.x = pointer.clientX; this.y = pointer.clientY; } }; // ---- 初始化 ---- const dancers = []; let ground = 1.0; const ctx = canvas.init(); pointer.init(canvas); let dancerDrag = null; let pointDrag = null; // ---- 主要循环 ---- const run = () => { requestAnimationFrame(run); ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = \"#222\"; ctx.fillRect(0, 0, canvas.width, canvas.height * 0.15); ctx.fillRect(0, canvas.height * 0.85, canvas.width, canvas.height * 0.15); for (const dancer of dancers) { dancer.update(); dancer.draw(); } }; // ---- 机器人构造 ---- const struct = { points: [ { x: 0, y: -4, f(s, d) { this.y -= 0.01 * s; } }, { x: 0, y: -16, f(s, d) { this.y -= 0.02 * s * d; } }, { x: 0, y: 12, f(s, d) { this.y += 0.02 * s * d; } }, { x: -12, y: 0 }, { x: 12, y: 0 }, { x: -3, y: 34, f(s, d) { if (d > 0) { this.x += 0.01 * s; this.y -= 0.015 * s; } else { this.y += 0.02 * s; } } }, { x: 3, y: 34, f(s, d) { if (d > 0) { this.y += 0.02 * s; } else { this.x -= 0.01 * s; this.y -= 0.015 * s; } } }, { x: -28, y: 0, f(s, d) { this.x += this.vx * 0.035; this.y -= 0.001 * s; } }, { x: 28, y: 0, f(s, d) { this.x += this.vx * 0.035; this.y -= 0.001 * s; } }, { x: -3, y: 64, f(s, d) { this.y += 0.015 * s; if (d > 0) { this.y -= 0.01 * s; } else { this.y += 0.05 * s; } } }, { x: 3, y: 64, f(s, d) { this.y += 0.015 * s; if (d > 0) { this.y += 0.05 * s; } else { this.y -= 0.01 * s; } } } ], links: [ { p0: 3, p1: 7, size: 12, lum: 0.5 }, { p0: 1, p1: 3, size: 24, lum: 0.5 }, { p0: 1, p1: 0, size: 60, lum: 0.5, disk: 1 }, { p0: 5, p1: 9, size: 16, lum: 0.5 }, { p0: 2, p1: 5, size: 32, lum: 0.5 }, { p0: 1, p1: 2, size: 50, lum: 1 }, { p0: 6, p1: 10, size: 16, lum: 1.5 }, { p0: 2, p1: 6, size: 32, lum: 1.5 }, { p0: 4, p1: 8, size: 12, lum: 1.5 }, { p0: 1, p1: 4, size: 24, lum: 1.5 } ] }; for (let i = 0; i < 6; i++) { dancers.push( new Robot( i * 360 / 7, 80, (window.location.href.indexOf(\"fullcpgrid\") > -1) ? 3 : 4, (i + 2) * canvas.width / 9, canvas.height * ground - 300, struct ) ); } run(); }","tags":[{"name":"HTML","slug":"HTML","permalink":"http://Rainylo.github.io/tags/HTML/"}]},{"title":"Hexo博客——不止于文字","date":"2018-04-29T03:08:56.000Z","path":"/posts/232c0b30/","text":"在文章中添加图片、音乐及视频 添加图片 首先更改_config.yml 中 post_asset_folder:true。当设置post_asset_folder为true参数后，在建立文件时，Hexo会自动建立一个与文章同名的文件夹，可以把与该文章相关的所有资源都放到这个文件夹，便于对每篇文章里的资源进行管理 在搭建的博客目录下打开Git bash ，执行: npm install https://github.com/CodeFalling/hexo-asset-image --save 完成安装后用Hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹。 把图片放在文件夹下面。此时，就可以在文章中添加如下代码格式即可插入图片： ![图片描述](文件夹名/图片名称.jpg) 也可以在source文件夹中新建images文件夹，把所有图片统一放置在里面（可以删除新建文章时创建的文件夹），使用绝对路径插入图片： ![图片描述](/img/图片名称.jpg) 相对路径和绝对路径两种方法各有好处，根据个人习惯选择。 添加音乐比如网易云音乐（网页版），找到喜欢的歌曲，点击生成外链播放器，把里面的代码复制下来，直接粘贴到博文中即可： 添加视频将你需要放置的本地视频上传至视频网站，比如哔哩哔哩、优酷、腾讯视频等等，审核通过后，点击分享按钮，复制iframe代码到文章中你指定的位置即可： 例如哔哩哔哩：","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://Rainylo.github.io/tags/Hexo/"}]},{"title":"Hexo搭建个人博客","date":"2018-04-27T12:38:04.000Z","path":"/posts/ec7d7221/","text":"使用Hexo+Github搭建个人博客 写在教程之前 前两天自己试着使用Hexo搭建了一个博客，也即是你们现在所看到的，搭建过程中出现过很多很多错误，失败重做至少五次，也曾想过放弃，不过我还是头铁挺了过来(还是太笨了233)，期间参照许多教程甚至询问其他博主，才有了现在这个正式版1.0。 在此，我衷心的感谢所有给予过我帮助的人！ 搭建博客 在搭建博客前，需要用到Git和node.js环境，所以需要提前到官网下载好，选择相应的版本，安装过程自行百度参考相关教程即可。 在我自己查找教程的过程中，发现由于教程的时间不同，分为许多不同的版本，许多命令也都有差异，而我没有多余时间来特意整理这些命令（或许等以后有时间了我会更新）。因此，我只能厚着脸皮引用一个我个人认为比较好比较全面的教程： 使用Hexo+Github一步步搭建属于自己的博客（基础） 使用Hexo+Github一步步搭建属于自己的博客（进阶） Tips 强烈推荐Hexo官网，里面有很多解释，不用怕英文看不懂，现在大多浏览器右键里都有翻译选项吧。如果搭建过程中有错误请仔细对比教程或自行百度搜索问题。 推荐一下个人认为比较好用的文本编辑器：Sublime，代码阅读起来也舒服。 可以在Hexo主题更换你的Hexo主题，点击图片可以预览，点击主题名可以跳转到下载链接，跳转后点击绿色按钮Clone or download即可下载，下载之后不要直接关闭下载页面，下滑滚轮，一般主题下面都有主题作者的说明和教程，可以省去很多很多麻烦。 如果你有购买域名的话，可以绑定到你已绑定github的博客，用自己的域名来访问，详细可以参考百度教程。 使用Hexo搭建的博客发布文章时，需要用到支持Markdown语法的编辑器，推荐使用CSDN提供的编辑器：http://write.blog.csdn.net/mdeditor Hexo博客还支持许多其他功能，例如gitalk评论功能等，由于我也才入门，所以有需要的自行百度吧。 常用的hexo命令 hexo clean 清空生成目录（public） hexo g 生成网站文件 hexo s 打开本地服务 localhost:4000 hexo d 将文件部署到github page hexo new xxx 新建一篇文章xxx（文件名不宜太长） hexo new page xxx 新建一个页面xxx 写在最后 看到这篇文章中许多链接或百度的字眼，你们可能要吐槽我只会搬运而不会原创了，在此我只能说句实在抱歉，我并不想用我有限的时间来偷工减料地完成一篇很有意义的教程，我自己所学也很有限，我并不想误导大家，所以引用那些比较完善的教程资料。 也许有人会说我懒不知道复制粘贴吗？其实，粘贴复制也是考验技术的2333，因为等你接触到Markdown语法就知道了，虽然这语法不难，但也要花些时间。我这样引用也算是尊重一下其他人的劳动成果吧。 如有其他问题，欢迎在文章下面留言或者直接私聊我，我会尽力解答。 这个是我所使用的主题：tomotoes","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://Rainylo.github.io/tags/Hexo/"}]},{"title":"页面点击效果","date":"2018-04-26T09:58:33.000Z","path":"/posts/5c2fafc7/","text":"实现页面点击桃心效果手机端也有特效哦 点击love.js 将里面全部代码复制，之后在路径/themes/“主题名”/source/js下新建love.js，将刚才复制的代码粘贴进love.js，打开/themes/“主题名”/layout/script.ejs（不同主题文件名可能不同），打开后在末尾添加以下代码： &lt;script type=&quot;text/javascript&quot; src=&quot;/js/love.js&quot;&gt;&lt;/script&gt; 到此，教程差不多就结束了，如果不成功可能是script代码添加位置不对，动手多试试吧！","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://Rainylo.github.io/tags/Hexo/"},{"name":"页面美化","slug":"页面美化","permalink":"http://Rainylo.github.io/tags/页面美化/"}]}]